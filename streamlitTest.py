# app.py
import streamlit as st
import os
import re
import json
import pandas as pd
from PIL import Image
import google.generativeai as genai
from io import StringIO
import base64
# --- Import local modules ---
from getImages import screenshot_table
from amazonTables import amazon_tables

GEMINI_API_KEY = "AIzaSyBQZ5Dnedsn62074kojZBQKVAUVvuh8Z54" 

if not GEMINI_API_KEY or GEMINI_API_KEY == "YOUR_GEMINI_API_KEY":
    st.warning("Gemini API Key not found or not set. Please set it. AI features will be disabled.", icon="‚ö†Ô∏è")
    ai_enabled = False
else:
    ai_enabled = True
    genai.configure(api_key=GEMINI_API_KEY) 

# --- Page Setup ---
st.set_page_config(page_title="Web Table Extractor", layout="wide")
st.title("üåê Web Table Extractor")
st.markdown("Extract data from tables on webpages. Handles Amazon product comparisons directly, uses AI for others.")

if 'extraction_method' not in st.session_state:
    st.session_state.extraction_method = None
if 'data_extracted' not in st.session_state:
    st.session_state.data_extracted = False
if 'extracted_content' not in st.session_state:
    st.session_state.extracted_content = None
if 'extracted_dataframe' not in st.session_state:
    st.session_state.extracted_dataframe = None
if 'extracted_format' not in st.session_state:
    st.session_state.extracted_format = None
if 'extracted_filename' not in st.session_state:
    st.session_state.extracted_filename = None
if 'screenshot_captured' not in st.session_state:
    st.session_state.screenshot_captured = False
if 'screenshot_filename' not in st.session_state:
    st.session_state.screenshot_filename = ""
if 'safe_title' not in st.session_state:
    st.session_state.safe_title = ""

def get_download_link(content, filename, text, format_type):
    """Creates a download link for text content."""
    if isinstance(content, bytes):
        b64 = base64.b64encode(content).decode()
    else:
        b64 = base64.b64encode(str(content).encode('utf-8')).decode() # Ensure UTF-8
    mime_type = {
        "CSV": "text/csv",
        "JSON": "application/json",
        "HTML": "text/html",
        "TEXT": "text/plain"
    }.get(format_type, "application/octet-stream")
    href = f'<a href="data:{mime_type};base64,{b64}" download="{filename}">{text}</a>'
    return href

# --- Input Section ---
url = st.text_input("Enter the URL of the webpage:", key="url_input")

is_amazon_product_page = bool(url and ("amazon.com" in url or "amzn." in url or "amzn.to" in url) and ("/dp/" in url or "/gp/product/" in url))

if is_amazon_product_page:
    st.info("Amazon product page detected. Direct extraction will be attempted.", icon="üõí")
    table_title = "" # Title not needed for Amazon
    button_text = "Extract Amazon Table"
else:
    st.info("General webpage detected. Screenshot + AI extraction will be used.", icon="üìÑ")
    table_title = st.text_input("Enter a title/description for the table (used for filename):", key="title_input")
    button_text = "Capture Table Screenshot"


format_type = st.selectbox(
    "Select desired output format:",
    options=["CSV", "JSON", "HTML"],
    index=0 # Default to CSV
)

# --- Action Button ---
if st.button(button_text, key="main_action_button", disabled=not url):

    # Reset state before action
    st.session_state.update({
        'data_extracted': False, 'extracted_content': None, 'extracted_dataframe': None,
        'extracted_format': None, 'extracted_filename': None, 'screenshot_captured': False,
        'screenshot_filename': "", 'extraction_method': None
    })


    progress = st.progress(0)
    status = st.empty()

    if is_amazon_product_page:
        # --- Amazon Direct Extraction Workflow ---
        st.session_state.extraction_method = 'amazon'
        status.text("Attempting direct extraction from Amazon...")
        progress.progress(25)

        # Call the imported function
        extracted_result = amazon_tables(url)
        progress.progress(75)

        # Check the status returned by the function
        if extracted_result['status'] == 'success':
            status.text("Amazon table extracted successfully!")
            df = extracted_result["dataframe"]
            html_content = extracted_result["html"] # Get HTML generated by scraper
            st.session_state.extracted_dataframe = df

            safe_filename_base = "amazon_comparison"
            try:
                if format_type == "CSV":
                    st.session_state.extracted_content = df.to_csv(index=False)
                elif format_type == "JSON":
                    st.session_state.extracted_content = df.to_json(orient="records", indent=2)
                else: # HTML
                    # Use the HTML generated by the scraper, maybe add basic structure
                    st.session_state.extracted_content = f"<html><head><meta charset='UTF-8'><title>Amazon Comparison</title></head><body>\n{html_content}\n</body></html>"

                st.session_state.extracted_format = format_type
                st.session_state.extracted_filename = f"{safe_filename_base}.{format_type.lower()}"
                st.session_state.data_extracted = True
                progress.progress(100)
                st.rerun() # Rerun to show results

            except Exception as e:
                 status.error(f"Error formatting extracted Amazon data: {e}")
                 st.session_state.data_extracted = False
                 progress.progress(100)

        else:
            # Handle different failure statuses from amazon_tables
            status.error(f"Amazon Extraction Failed: {extracted_result.get('message', 'Unknown error')}")
            st.error(f"Details: {extracted_result.get('message', 'No further details.')}") # Show message prominently
            progress.progress(100)
            st.session_state.data_extracted = False

    else:
        # --- Screenshot + AI Workflow ---
        st.session_state.extraction_method = 'ai'
        if not table_title:
            st.warning("Please enter a title/description for the table to proceed with screenshot capture.")
            st.stop()

        status.text("Capturing table screenshot...")
        progress.progress(30)

        try:
            safe_title = re.sub(r'[^\w\s-]', '', table_title).strip()
            safe_title = re.sub(r'[-\s]+', '_', safe_title) if safe_title else "table_screenshot"
            st.session_state.safe_title = safe_title

            # --- Call screenshot function ---
            predicted_filename = f"table_{safe_title}_screenshot.png"
            try:
                 # Assuming screenshot_table might raise error on failure
                 screenshot_table(url, table_title) # Consider passing predicted_filename if possible
                 # Verify file exists AFTER calling the function
                 if not os.path.exists(predicted_filename):
                      # Try fallback names if your function uses them
                      if os.path.exists("full_page_screenshot.png"):
                           predicted_filename = "full_page_screenshot.png"
                           st.warning("Using full page screenshot as specific table capture might have failed.")
                      else:
                           raise FileNotFoundError(f"Screenshot file '{predicted_filename}' or fallbacks not found.")
                 screenshot_filename = predicted_filename

            except Exception as ss_error:
                 st.error(f"Screenshot function failed: {ss_error}")
                 import traceback
                 st.expander("Traceback").code(traceback.format_exc())
                 st.stop()


            st.session_state.screenshot_captured = True
            st.session_state.screenshot_filename = screenshot_filename
            progress.progress(100)
            status.text("Screenshot captured successfully!")
            st.rerun()

        except Exception as e:
            st.error(f"An error occurred during screenshot capture setup: {str(e)}")
            import traceback
            st.expander("Traceback").code(traceback.format_exc())
            progress.progress(100)


# --- Display Screenshot and AI Extraction Button (AI Path Only) ---
if st.session_state.extraction_method == 'ai' and st.session_state.screenshot_captured:
    st.markdown("---")
    st.subheader("Step 2: Verify Screenshot & Extract Data")
    screenshot_file = st.session_state.screenshot_filename
    if os.path.exists(screenshot_file):
        try:
            image = Image.open(screenshot_file)
            st.image(image, caption=f"Captured: {st.session_state.safe_title}", use_container_width=True)
        except Exception as img_e:
            st.error(f"Error loading screenshot image: {img_e}")
            st.session_state.screenshot_captured = False # Reset
    else:
        st.error(f"Screenshot file not found: {screenshot_file}")
        st.session_state.screenshot_captured = False # Reset state

    col1, col2 = st.columns(2)
    with col1:
        if st.button("‚ùå Delete Screenshot", use_container_width=True):
            if os.path.exists(screenshot_file):
                try:
                    os.remove(screenshot_file)
                    st.success("Screenshot deleted.")
                except OSError as e:
                    st.error(f"Error deleting file: {e}")
            st.session_state.update({
                'screenshot_captured': False, 'screenshot_filename': "",
                'extraction_method': None, 'data_extracted': False
            })
            st.rerun()

    with col2:
        # Disable button if AI is not enabled
        if st.button("‚ú® Extract Data via AI", use_container_width=True, type="primary", disabled=not ai_enabled):
            if not ai_enabled: # Should be caught by disabled, but double check
                 st.error("Gemini API Key is required for AI extraction.")
                 st.stop()

            progress = st.progress(0)
            status = st.empty()
            try:
                status.text("Processing screenshot with Gemini API...")
                progress.progress(10)

                if not GEMINI_API_KEY:
                    st.error("Please provide a valid Gemini API key to use the Q&A feature.")
                    st.stop()
                model = genai.GenerativeModel('gemini-1.5-flash')
                try:
                    if not os.path.exists(screenshot_file):
                         raise FileNotFoundError(f"Screenshot file missing: {screenshot_file}")
                    image = Image.open(screenshot_file)
                except Exception as img_e:
                    st.error(f"Error opening screenshot for AI: {img_e}")
                    st.stop()

                prompt = f"Extract the table data accurately from the image. Output the result ONLY in {format_type} format, without any introductory text, explanations, or markdown formatting like ```. Just provide the raw {format_type} data."
                progress.progress(30)

                response = model.generate_content([prompt, image], request_options={"timeout": 120}) # Add timeout
                progress.progress(80)
                result_text = response.text.strip()

                # Basic cleaning (remove potential markdown blocks if model added them)
                markers = { "JSON": "json", "CSV": "csv", "HTML": "html" }
                marker = markers.get(format_type)
                if marker and result_text.startswith(f"```{marker}"):
                    result_text = result_text.split(f"```{marker}", 1)[1].rsplit("```", 1)[0].strip()
                elif result_text.startswith("```"):
                    result_text = result_text.split("```", 1)[1].rsplit("```", 1)[0].strip()

                st.session_state.extracted_content = result_text
                st.session_state.extracted_format = format_type
                st.session_state.extracted_filename = f"{st.session_state.safe_title}.{format_type.lower()}"
                st.session_state.data_extracted = True
                st.session_state.extracted_dataframe = None # Reset DF

                # Attempt to create DataFrame for preview
                try:
                    if format_type == "CSV" and result_text:
                        st.session_state.extracted_dataframe = pd.read_csv(StringIO(result_text))
                    elif format_type == "JSON" and result_text:
                        try:
                            json_data = json.loads(result_text)
                            if isinstance(json_data, list):
                                st.session_state.extracted_dataframe = pd.DataFrame(json_data)
                            # Optionally handle dict if needed: elif isinstance(json_data, dict): ...
                        except (json.JSONDecodeError, TypeError) as json_e:
                             print(f"AI JSON parse to DF failed: {json_e}")
                except Exception as parse_error:
                    st.warning(f"Could not auto-parse AI result into DataFrame: {parse_error}")

                status.text("AI extraction completed!")
                progress.progress(100)
                st.rerun()

            except Exception as e:
                st.error(f"An error occurred during AI extraction: {str(e)}")
                import traceback
                st.expander("Traceback").code(traceback.format_exc())
                progress.progress(100)


# --- Display Results and Download Link (Common Section) ---
if st.session_state.data_extracted:
    st.markdown("---")
    st.header("üìä Extracted Data Preview")

    data_format = st.session_state.extracted_format
    data_content = st.session_state.extracted_content
    data_df = st.session_state.extracted_dataframe

    if data_df is not None:
        st.dataframe(data_df)
        st.caption(f"Preview based on DataFrame ({data_df.shape[0]} rows, {data_df.shape[1]} cols)")
        with st.expander(f"View Raw {data_format} Output"):
             display_format = 'json' if data_format == 'JSON' else data_format.lower()
             try:
                if data_format == "HTML": st.code(data_content, language='html')
                elif data_format == "JSON": st.json(data_content) # Use st.json for strings
                else: st.text(data_content)
             except Exception as display_err: # Catch potential display errors
                 st.text(f"Raw content:\n{data_content}")

    elif data_content:
         st.caption(f"Raw {data_format} Output (DataFrame preview not available)")
         if data_format == "HTML":
             st.components.v1.html(data_content, height=400, scrolling=True)
             with st.expander("View HTML Code"): st.code(data_content, language='html')
         elif data_format == "JSON":
             st.json(data_content) # Handles JSON string
         else: # CSV or other text
             st.text_area("Raw Output", data_content, height=300)
    else:
         st.warning("No extracted content available to display.")


    # Download Link
    if data_content and st.session_state.extracted_filename:
        st.markdown("---")
        st.subheader("‚¨áÔ∏è Download Extracted Data")
        try:
            download_link = get_download_link(
                data_content,
                st.session_state.extracted_filename,
                f"Download as {data_format} ({st.session_state.extracted_filename})",
                data_format # Pass format_type for MIME lookup
            )
            st.markdown(download_link, unsafe_allow_html=True)
        except Exception as dl_error:
             st.error(f"Error generating download link: {dl_error}")


    # --- Q&A Section ---
    if ai_enabled: # Only show if AI is available
        st.markdown("---")
        st.header("‚ùì Ask Questions About Your Table")
        st.markdown("Uses the extracted text content for context.")

        table_context_for_qa = st.session_state.extracted_content

        if table_context_for_qa:
            col1, col2 = st.columns([4, 1])
            with col1:
                question = st.text_input("Your question:", key="table_question_input")
            with col2:
                submit_question = st.button("Ask Gemini", use_container_width=True, key="ask_button")

            if submit_question and question:
                try:
                    with st.spinner("üß† Thinking..."):
                        # Model should already be configured if ai_enabled is True
                        model = genai.GenerativeModel('gemini-1.5-flash')

                        qa_prompt = f"""Based *only* on the following table data, answer the user's question accurately. If the question cannot be answered from the provided data, state that clearly. Do not make up information.
                        If the question is unrelated to the table or extracted data reply with "UNRELATED: Question unrelated to table, Please ask a question related to the table".

                        Table Data ({st.session_state.extracted_format} format):
                        ```
                        {table_context_for_qa}
                        ```

                        User Question: {question}

                        Answer:"""

                        response = model.generate_content(qa_prompt, request_options={"timeout": 60})
                        answer = response.text.strip()

                        if answer.startswith("UNRELATED:"):
                            st.warning(answer.replace("UNRELATED: ", ""))
                        else:
                            st.success(answer)
                            # st.markdown(answer)

                except Exception as e:
                    st.error(f"An error occurred processing your question: {str(e)}")
                    with st.expander("See error details"):
                         st.exception(e)
        else:
             st.info("No extracted data available to ask questions about.")